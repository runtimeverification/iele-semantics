#!/usr/bin/python3

import argparse
import sys
import json
from .fetchFunctionData import fetch_function_data
from .blackbox import *
from .testrunner import *
from .rpc import *
from .config import config
from .kieleCoverage import *
import os

def make_parser():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')

    blackboxParser = subparsers.add_parser('blackbox', help = 'Blackbox testing.')
    blackboxParser.add_argument('-p', '--port', type=int, default=8546, metavar="<port>",
                      help="Port that Midnight client is listen on (default: %(default)s)")
    blackboxParser.add_argument('-o', '--timeout', type=int, default=15, metavar="<coverage timeout>",
                      help="Timeout for trying each function (default: %(default)s)")
    blackboxParser.add_argument('--build-dir', type=str, default="contract_artifacts", metavar="<build dir>",
                      help="Path to the JSON output of solc (default: %(default)s)")
    blackboxParser.add_argument('--passphrase', type=str, default="walletNotSecure", metavar="<passphrase>",
                      help="Wallet passphrase (default: %(default)s)")
    blackboxParser.add_argument('--master-key', type=str, default="m-test-shl-mk1d32eztqfzu2qffa3png853374823yme8rjp9azkhsnj8fxaymx9q8dc45t", metavar="<master key>",
                      help="Wallet master key (default: %(default)s)")

    testrunnerParser = subparsers.add_parser('test', help = "Test runner.")
    testrunnerParser.add_argument('-p', '--port', type=int, default=8546, metavar="<port>",
                        help="Port that Midnight client is listen on (default: %(default)s)")
    testrunnerParser.add_argument('-l', '--gas-limit', type=str, default="0x166f5777", metavar="<gas limit>",
                        help="Transaction gas limit (default: %(default)s)")
    testrunnerParser.add_argument('-g', '--gas-price', type=str, default="0x0", metavar="<gas price>",
                        help="Gas price value (default: %(default)s)")
    testrunnerParser.add_argument('-f', '--file', type=str, metavar="<tests>",
                        help="Path of the test file/files to be executed (default: %(default)s)")
    testrunnerParser.add_argument('--build-dir', type=str, default="contract_artifacts", metavar="<build dir>",
                        help="Path to the JSON output of solc (default: %(default)s)")
    testrunnerParser.add_argument('--passphrase', type=str, default="walletNotSecure", metavar="<passphrase>",
                        help="Wallet passphrase (default: %(default)s)")
    testrunnerParser.add_argument('--master-key', type=str, default="m-test-shl-mk1d32eztqfzu2qffa3png853374823yme8rjp9azkhsnj8fxaymx9q8dc45t", metavar="<master key>",
                        help="Wallet master key (default: %(default)s)")
    testrunnerParser.add_argument('--tests-dir', type=str, default="tests", metavar="<tests-dir>",
                        help="Path to the default tests directory (default: %(default)s)")

    compileParser = subparsers.add_parser('compile', help='Compiling Solidity contracts using isolc.')
    compileParser.add_argument('-f', '--file', type=str, metavar="<solidity-file>",
                     help="Path to the Solidity file/dir to be compiled")
    compileParser.add_argument('--contracts-dir', type=str, default="contracts", metavar="<contracts-dir>",
                     help="Path to the default contracts directory (default: %(default)s)")
    compileParser.add_argument('--build-dir', type=str, default="contract_artifacts", metavar="<build dir>",
                     help="Path to the JSON output of solc (default: %(default)s)")

    coverageParser = subparsers.add_parser('coverage', help='Generate report.json')
    coverageParser.add_argument(type=str, metavar='<isolc combined-json>', dest='combined',
                      help='combined.json file generated by isolc with asm,srcmap options')
    coverageParser.add_argument('-o', '--output', type=str, default='report.json', metavar='<output file>', dest='output',
                      help='Output file')
    coverageParser.add_argument('-p', '--port', type=int, default=8546, metavar='<port>', dest='port',
                      help='Port number for RPC client')

    return parser


if __name__ == '__main__':
    parser = make_parser()
    args = parser.parse_args()

    if args.command == 'compile':
        config.contracts_dir=args.contracts_dir
        config.target_directory=args.build_dir
        compile(args.file)

    elif args.command == 'test':
        config.port = args.port
        config.gas_limit = args.gas_limit
        config.gas_price = args.gas_price
        config.tests_dir = args.tests_dir
        config.target_directory = args.build_dir
        config.master_key = args.master_key
        config.passphrase = args.passphrase

        if(args.file is None):
            if os.path.isdir(config.tests_dir):
                for child_file in os.listdir(config.tests_dir):
                    if child_file.endswith(".sol"):
                        run_test_file(config.tests_dir + "/" + child_file)
            elif os.path.isfile(config.test_dir):
                    if child_file.endswith(".sol"):
                        run_test_file(child_file)
        else:
            file_path = args.file
            if (os.path.isdir(file_path)):
                for child_file in os.listdir(file_path):
                    if child_file.endswith(".sol"):
                        run_test_file(file_path + "/" + child_file)
            elif (os.path.isfile(file_path) and (file_path).endswith(".sol")):
                run_test_file(file_path)
            else:
                fatal("Invalid file: "+ file_path)
        print("==  Passing Tests:", config.passing_tests)
        print("==  Failing Tests:", config.failing_tests)

    elif args.command == 'blackbox':
        config.port = args.port
        config.coverage_timeout = timeout=args.timeout
        config.master_key = args.master_key
        config.passphrase = args.passphrase

        notif("Collecting data for blackbox random testing...")

        # Retrive coverage_report,contract_map
        coverage_report = get_coverage_report()
        contract_map = get_contract_map(config.target_directory)

        # Extract contracts that are available for blackbox testing
        available_contract = get_available_contract(coverage_report, contract_map)

        notif("Preparation finished, altogether " + str(len(available_contract)) + " contacts to test")
        notif("")

        # Process contracts in alphabetical order
        available_contract = dict(sorted(available_contract.items()))
        all_calls = []
        all_constructors = {}
        for solidity_file in available_contract:
            contract_json = config.target_directory + "/" + get_file_name(solidity_file) + ".json"
            solidity_functions = fetch_function_data(contract_json)
            for contract in solidity_functions:
                if(not contract["contractName"] in list(available_contract.keys())):
                    continue
                contract_calls, constructor_info = blackbox_test_single_contract(contract, available_contract)
                all_calls.extend(contract_calls)
            if len(constructor_info) == 0:
                all_constructors[solidity_file] = []
            else:
                all_constructors[solidity_file] = constructor_info[0]["input"]

        # Write founded tests to blackbox-random.json
        with open('blackbox-random.json', 'w') as outfile:
            json.dump(all_calls, outfile)

    elif args.command == 'coverage':
        """ Parse command line arguments """
        config.port = args.port

        """ Start JSON report with locally available data """
        data = []
        with open(args.combined) as f:
          data = json.load(f)

        try:
          output = create_local_data(data)
        except KeyError as key:
          if key.args[0] in ['asm','bin','metadata-bin','srcmap']:
              print(f"""[ERROR] KeyError while reading "{args.combined}": {key} """)
              print("[ERROR] Make sure you compiled with '--combined-json asm,bin,metadata-bin,srcmap'")
              sys.exit(1)
          else:
              raise key

        """ Get coverage from client """
        retrieve_coverage(output, args.port)

        with open(args.output, mode='w') as f:
          f.write(json.dumps(output, indent=2))

